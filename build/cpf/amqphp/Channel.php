<?php
 namespace amqphp; use amqphp\protocol; use amqphp\wire; class Channel { private $myConn; private $chanId; private $flow = true; private $destroyed = false; private $frameMax; private $isOpen = false; private $consumers = array(); private $callbacks = array('publishConfirm' => null, 'publishReturn' => null, 'publishNack' => null); private $confirmSeqs = array(); private $confirmSeq = 0; private $confirmMode = false; function setPublishConfirmCallback (\Closure $c) { $this->callbacks['publishConfirm'] = $c; } function setPublishReturnCallback (\Closure $c) { $this->callbacks['publishReturn'] = $c; } function setPublishNackCallback (\Closure $c) { $this->callbacks['publishNack'] = $c; } function hasOutstandingConfirms () { return (bool) $this->confirmSeqs; } function setConfirmMode () { if ($this->confirmMode) { return; } $confSelect = $this->confirm('select'); $confSelectOk = $this->invoke($confSelect); if (! ($confSelectOk instanceof wire\Method) || ! ($confSelectOk->getClassProto()->getSpecName() == 'confirm' && $confSelectOk->getMethodProto()->getSpecName() == 'select-ok')) { throw new \Exception("Failed to selectg confirm mode", 8674); } $this->confirmMode = true; } function __construct (Connection $rConn, $chanId, $frameMax) { $this->myConn = $rConn; $this->chanId = $chanId; $this->frameMax = $frameMax; $this->callbacks['publishConfirm'] = $this->callbacks['publishReturn'] = function () {}; } function initChannel () { $pl = $this->myConn->getProtocolLoader(); $meth = new wire\Method($pl('ClassFactory', 'GetMethod', array('channel', 'open')), $this->chanId); $meth->setField('reserved-1', ''); $resp = $this->myConn->invoke($meth); } function __call ($class, $_args) { if ($this->destroyed) { throw new \Exception("Attempting to use a destroyed channel", 8766); } $m = $this->myConn->constructMethod($class, $_args); $m->setWireChannel($this->chanId); $m->setMaxFrameSize($this->frameMax); return $m; } function invoke (wire\Method $m) { if ($this->destroyed) { throw new \Exception("Attempting to use a destroyed channel", 8767); } else if (! $this->flow) { trigger_error("Channel is closed", E_USER_WARNING); return; } else if (is_null($tmp = $m->getWireChannel())) { $m->setWireChannel($this->chanId); } else if ($tmp != $this->chanId) { throw new \Exception("Method is invoked through the wrong channel", 7645); } if ($this->confirmMode && $m->getClassProto()->getSpecName() == 'basic' && $m->getMethodProto()->getSpecName() == 'publish') { $this->confirmSeq++; $this->confirmSeqs[] = $this->confirmSeq; } return $this->myConn->invoke($m); } function handleChannelMessage (wire\Method $meth) { $sid = "{$meth->getClassProto()->getSpecName()}.{$meth->getMethodProto()->getSpecName()}"; switch ($sid) { case 'channel.flow': $this->flow = ! $this->flow; if ($r = $meth->getMethodProto()->getResponses()) { $meth = new wire\Method($r[0]); $meth->setWireChannel($this->chanId); $this->invoke($meth); } return false; break; case 'channel.close': $pl = $this->myConn->getProtocolLoader(); if ($culprit = $pl('ClassFactory', 'GetMethod', array($meth->getField('class-id'), $meth->getField('method-id')))) { $culprit = "{$culprit->getSpecClass()}.{$culprit->getSpecName()}"; } else { $culprit = '(Unknown or unspecified)'; } $errCode = $pl('ProtoConsts'. 'Konstant', array($meth->getField('reply-code'))); $eb = ''; foreach ($meth->getFields() as $k => $v) { $eb .= sprintf("(%s=%s) ", $k, $v); } $tmp = $meth->getMethodProto()->getResponses(); $closeOk = new wire\Method($tmp[0]); $em = "[channel.close] reply-code={$errCode['name']} triggered by $culprit: $eb"; try { $this->myConn->invoke($closeOk); $em .= " Channel closed OK"; $n = 3687; } catch (\Exception $e) { $em .= " Additionally, channel closure ack send failed"; $n = 2435; } throw new \Exception($em, $n); case 'channel.close-ok': case 'channel.open-ok': return true; default: throw new \Exception("Received unexpected channel message: $sid", 8795); } } function handleChannelDelivery (wire\Method $meth) { $sid = "{$meth->getClassProto()->getSpecName()}.{$meth->getMethodProto()->getSpecName()}"; switch ($sid) { case 'basic.deliver': return $this->deliverConsumerMessage($meth, $sid); case 'basic.return': $cb = $this->callbacks['publishReturn']; return false; case 'basic.ack': $cb = $this->callbacks['publishConfirm']; $this->removeConfirmSeqs($meth, $cb); return false; case 'basic.nack': $cb = $this->callbacks['publishNack']; $this->removeConfirmSeqs($meth, $cb); return false; default: throw new \Exception("Received unexpected channel delivery:\n$sid", 87998); } } private function deliverConsumerMessage ($meth, $sid) { $ctag = $meth->getField('consumer-tag'); list($cons, $status) = $this->getConsumerAndStatus($ctag); $response = $cons->handleDelivery($meth, $this); if ($sid !== 'basic.deliver' || ! $response) { return false; } if (! is_array($response)) { $response = array($response); } foreach ($response as $resp) { switch ($resp) { case CONSUMER_ACK: $ack = $this->basic('ack', array('delivery-tag' => $meth->getField('delivery-tag'), 'multiple' => false)); $this->invoke($ack); break; case CONSUMER_DROP: case CONSUMER_REJECT: $rej = $this->basic('reject', array('delivery-tag' => $meth->getField('delivery-tag'), 'requeue' => ($resp == CONSUMER_REJECT))); $this->invoke($rej); break; case CONSUMER_CANCEL: $cnl = $this->basic('cancel', array('consumer-tag' => $ctag, 'no-wait' => false)); $cOk = $this->invoke($cnl); if ($cOk && ($cOk->getClassProto()->getSpecName() == 'basic' && $cOk->getMethodProto()->getSpecName() == 'cancel-ok')) { $this->setConsumerStatus($ctag, 'CLOSED') OR trigger_error("Failed to set consumer status flag", E_USER_WARNING); } else { throw new \Exception("Failed to cancel consumer - bad broker response", 9768); } $cons->handleCancelOk($cOk, $this); break; } } return false; } private function removeConfirmSeqs (wire\Method $meth, \Closure $handler = null) { if ($meth->getField('multiple')) { $dtag = $meth->getField('delivery-tag'); $this->confirmSeqs = array_filter($this->confirmSeqs, function ($id) use ($dtag, $handler, $meth) { if ($id <= $dtag) { if ($handler) { $handler($meth); } return false; } else { return true; } }); } else { $dt = $meth->getField('delivery-tag'); if (isset($this->confirmSeqs)) { if ($handler) { $handler($meth); } unset($this->confirmSeqs[array_search($dt, $this->confirmSeqs)]); } } } function shutdown () { if (! $this->invoke($this->channel('close', array('reply-code' => '', 'reply-text' => '')))) { trigger_error("Unclean channel shutdown", E_USER_WARNING); } $this->myConn->removeChannel($this); $this->destroyed = true; $this->myConn = $this->chanId = $this->ticket = null; } function addConsumer (Consumer $cons) { foreach ($this->consumers as $c) { if ($c === $cons) { throw new \Exception("Consumer can only be added to channel once", 9684); } } $this->consumers[] = array($cons, false, 'READY_WAIT'); } function canListen (){ return $this->hasListeningConsumers() || $this->hasOutstandingConfirms(); } function removeConsumer (Consumer $cons) { trigger_error("Consumers can no longer be directly removed", E_USER_DEPRECATED); return; } private function setConsumerStatus ($tag, $status) { foreach ($this->consumers as $k => $c) { if ($c[1] === $tag) { $this->consumers[$k][2] = $status; return true; } } return false; } private function getConsumerAndStatus ($tag) { foreach ($this->consumers as $c) { if ($c[1] == $tag) { return array($c[0], $c[2]); } } return array(null, 'INVALID'); } function hasListeningConsumers () { foreach ($this->consumers as $c) { if ($c[2] === 'READY') { return true; } } return false; } function onSelectStart () { if (! $this->consumers) { return false; } foreach (array_keys($this->consumers) as $cnum) { if (false === $this->consumers[$cnum][1]) { $consume = $this->consumers[$cnum][0]->getConsumeMethod($this); $cOk = $this->invoke($consume); $this->consumers[$cnum][0]->handleConsumeOk($cOk, $this); $this->consumers[$cnum][2] = 'READY'; $this->consumers[$cnum][1] = $cOk->getField('consumer-tag'); } } return true; } function onSelectEnd () { $this->consuming = false; } } 