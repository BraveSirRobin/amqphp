<?php
 namespace amqphp; use amqphp\protocol; use amqphp\wire; const DEBUG = false; const PROTOCOL_HEADER = "AMQP\x00\x00\x09\x01"; const STRAT_TIMEOUT_ABS = 1; const STRAT_TIMEOUT_REL = 2; const STRAT_MAXLOOPS = 3; const STRAT_CALLBACK = 4; const STRAT_COND = 5; const CONSUMER_ACK = 1; const CONSUMER_REJECT = 2; const CONSUMER_DROP = 3; const CONSUMER_CANCEL = 4; class Connection { public static $ClientProperties = array( 'product' => ' BraveSirRobin/amqphp', 'version' => '0.9.0', 'platform' => 'PHP 5.3 +', 'copyright' => 'Copyright (c) 2010,2011 Robin Harvey (harvey.robin@gmail.com)', 'information' => 'This software is released under the terms of the GNU LGPL: http://www.gnu.org/licenses/lgpl-3.0.txt'); public $capabilities; private static $CProps = array( 'socketImpl', 'socketParams', 'username', 'userpass', 'vhost', 'frameMax', 'chanMax', 'signalDispatch', 'heartbeat', 'socketFlags'); protected $sock; protected $socketImpl = '\amqphp\Socket'; protected $protoImpl = 'v0_9_1'; private $protoLoader; protected $socketParams = array('host' => 'localhost', 'port' => 5672); private $socketFlags; private $username; private $userpass; protected $vhost; protected $frameMax = 65536; protected $chanMax = 50; private $heartbeat = 0; protected $signalDispatch = true; protected $chans = array(); protected $nextChan = 1; private $blocking = false; protected $unDelivered = array(); protected $unDeliverable = array(); protected $incompleteMethods = array(); protected $readSrc = null; protected $connected = false; private $exStrats = array(); function __construct (array $params = array()) { $this->setConnectionParams($params); } function setConnectionParams (array $params) { foreach (self::$CProps as $pn) { if (isset($params[$pn])) { $this->$pn = $params[$pn]; } } } function getProtocolLoader () { if (is_null($this->protoLoader)) { $protoImpl = $this->protoImpl; $this->protoLoader = function ($class, $method, $args) use ($protoImpl) { $fqClass = '\\amqphp\\protocol\\' . $protoImpl . '\\' . $class; return call_user_func_array(array($fqClass, $method), $args); }; } return $this->protoLoader; } function shutdown () { if (! $this->connected) { trigger_error("Cannot shut a closed connection", E_USER_WARNING); return; } foreach (array_keys($this->chans) as $cName) { $this->chans[$cName]->shutdown(); } $pl = $this->getProtocolLoader(); $meth = new wire\Method($pl('ClassFactory', 'GetMethod', array('connection', 'close'))); $meth->setField('reply-code', ''); $meth->setField('reply-text', ''); $meth->setField('class-id', ''); $meth->setField('method-id', ''); if (! $this->write($meth->toBin($pl))) { trigger_error("Unclean connection shutdown (1)", E_USER_WARNING); return; } if (! ($raw = $this->read())) { trigger_error("Unclean connection shutdown (2)", E_USER_WARNING); return; } $meth = new wire\Method(); $meth->readConstruct(new wire\Reader($raw), $pl); if ($meth->amqpClass != 'connection.close-ok') { trigger_error("Channel protocol shudown fault", E_USER_WARNING); } $this->sock->close(); $this->connected = false; } protected function initSocket () { if (! isset($this->socketImpl)) { throw new \Exception("No socket implementation specified", 7545); } $this->sock = new $this->socketImpl($this->socketParams, $this->socketFlags, $this->vhost); } function connect () { if ($this->connected) { trigger_error("Connection is connected already", E_USER_WARNING); return; } $this->initSocket(); $this->sock->connect(); $this->doConnectionStartup(); } protected function doConnectionStartup () { if (! $this->write(PROTOCOL_HEADER)) { throw new \Exception("Connection initialisation failed (1)", 9873); } if (! ($raw = $this->read())) { throw new \Exception("Connection initialisation failed (2)", 9874); } if (substr($raw, 0, 4) == 'AMQP' && $raw !== PROTOCOL_HEADER) { throw new \Exception("Connection initialisation failed (3)", 9875); } $meth = new wire\Method(); $pl = $this->getProtocolLoader(); $meth->readConstruct(new wire\Reader($raw), $pl); if (($startF = $meth->getField('server-properties')) && isset($startF['capabilities']) && ($startF['capabilities']->getType() == 'F')) { $this->capabilities = $startF['capabilities']->getValue()->getArrayCopy(); } if ($meth->amqpClass == 'connection.start') { $resp = $meth->getMethodProto()->getResponses(); $meth = new wire\Method($resp[0]); } else { throw new \Exception("Connection initialisation failed (5)", 9877); } $meth->setField('client-properties', $this->getClientProperties()); $meth->setField('mechanism', 'AMQPLAIN'); $meth->setField('response', $this->getSaslResponse()); $meth->setField('locale', 'en_US'); if (! ($this->write($meth->toBin($pl)))) { throw new \Exception("Connection initialisation failed (6)", 9878); } if (! ($raw = $this->read())) { throw new \Exception("Connection initialisation failed (7)", 9879); } $meth = new wire\Method(); $meth->readConstruct(new wire\Reader($raw), $pl); $chanMax = $meth->getField('channel-max'); $frameMax = $meth->getField('frame-max'); $this->chanMax = ($chanMax < $this->chanMax) ? $chanMax : $this->chanMax; $this->frameMax = ($this->frameMax == 0 || $frameMax < $this->frameMax) ? $frameMax : $this->frameMax; if ($meth->amqpClass == 'connection.tune') { $resp = $meth->getMethodProto()->getResponses(); $meth = new wire\Method($resp[0]); } else { throw new \Exception("Connection initialisation failed (9)", 9881); } $meth->setField('channel-max', $this->chanMax); $meth->setField('frame-max', $this->frameMax); $meth->setField('heartbeat', $this->heartbeat); if (! ($this->write($meth->toBin($pl)))) { throw new \Exception("Connection initialisation failed (10)", 9882); } $meth = $this->constructMethod('connection', array('open', array('virtual-host' => $this->vhost))); $meth = $this->invoke($meth); if ($meth->amqpClass != 'connection.open-ok') { throw new \Exception("Connection initialisation failed (13)", 9885); } $this->connected = true; } private function getClientProperties () { $t = new wire\Table; foreach (self::$ClientProperties as $pn => $pv) { $t[$pn] = new wire\TableField($pv, 'S'); } return $t; } private function getSaslResponse () { $t = new wire\Table(); $t['LOGIN'] = new wire\TableField($this->username, 'S'); $t['PASSWORD'] = new wire\TableField($this->userpass, 'S'); $w = new wire\Writer(); $w->write($t, 'table'); return substr($w->getBuffer(), 4); } function getChannel ($num) { return $this->chans[$num]; } function openChannel () { return $this->initNewChannel(__NAMESPACE__ . '\\Channel'); } function getChannels () { return $this->chans; } function setSignalDispatch ($val) { $this->signalDispatch = (boolean) $val; } function getSignalDispatch () { return $this->signalDispatch; } function removeChannel (Channel $chan) { if (false !== ($k = array_search($chan, $this->chans))) { unset($this->chans[$k]); } else { trigger_error("Channel not found", E_USER_WARNING); } } function getSocketId () { return $this->sock->getId(); } function getSocketCK () { return $this->sock->getCK(); } protected function initNewChannel ($impl=null) { if (! $this->connected) { trigger_error("Connection is not connected - cannot create Channel", E_USER_WARNING); return null; } $newChan = $this->nextChan++; if ($this->chanMax > 0 && $newChan > $this->chanMax) { throw new \Exception("Channels are exhausted!", 23756); } $this->chans[$newChan] = is_null($impl) ? new Channel : new $impl; $this->chans[$newChan]->setConnection($this); $this->chans[$newChan]->setChanId($newChan); $this->chans[$newChan]->setFrameMax($this->frameMax); $this->chans[$newChan]->initChannel(); return $this->chans[$newChan]; } function getVHost () { return $this->vhost; } function getSocketImplClass () { return $this->socketImpl; } function isConnected () { return $this->connected; } private function read () { $ret = $this->sock->read(); if ($ret === false) { $errNo = $this->sock->lastError(); if ($this->signalDispatch && $this->sock->selectInterrupted()) { pcntl_signal_dispatch(); } $errStr = $this->sock->strError(); throw new \Exception ("[1] Read block select produced an error: [$errNo] $errStr", 9963); } return $ret; } private function write ($buffs) { $bw = 0; foreach ((array) $buffs as $buff) { $bw += $this->sock->write($buff); } return $bw; } private function handleConnectionMessage (wire\Method $meth) { if ($meth->isHeartbeat()) { $resp = "\x08\x00\x00\x00\x00\x00\x00\xce"; $this->write($resp); return; } switch ($meth->amqpClass) { case 'connection.close': $pl = $this->getProtocolLoader(); if ($culprit = $pl('ClassFactory', 'GetMethod', array($meth->getField('class-id'), $meth->getField('method-id')))) { $culprit = $culprit->getSpecName(); } else { $culprit = '(Unknown or unspecified)'; } $errCode = $pl('ProtoConsts', 'Konstant', array($meth->getField('reply-code'))); $eb = ''; foreach ($meth->getFields() as $k => $v) { $eb .= sprintf("(%s=%s) ", $k, $v); } $tmp = $meth->getMethodProto()->getResponses(); $closeOk = new wire\Method($tmp[0]); $em = "[connection.close] reply-code={$errCode['name']} triggered by $culprit: $eb"; if ($this->write($closeOk->toBin($pl))) { $em .= " Connection closed OK"; $n = 7565; } else { $em .= " Additionally, connection closure ack send failed"; $n = 7566; } $this->sock->close(); throw new \Exception($em, $n); default: $this->sock->close(); throw new \Exception(sprintf("Unexpected channel message (%s), connection closed", $meth->amqpClass), 96356); } } function isBlocking () { return $this->blocking; } function setBlocking ($b) { $this->blocking = (boolean) $b; } function select () { $evl = new EventLoop; $evl->addConnection($this); $evl->select(); } function pushExitStrategy () { if ($this->blocking) { trigger_error("Push exit strategy - cannot switch mode whilst blocking", E_USER_WARNING); return false; } $_args = func_get_args(); if (! $_args) { trigger_error("Push exit strategy - no select parameters supplied", E_USER_WARNING); return false; } switch ($mode = array_shift($_args)) { case STRAT_TIMEOUT_ABS: case STRAT_TIMEOUT_REL: @list($epoch, $usecs) = $_args; $this->exStrats[] = $tmp = new TimeoutExitStrategy; return $tmp->configure($mode, $epoch, $usecs); case STRAT_MAXLOOPS: $this->exStrats[] = $tmp = new MaxloopExitStrategy; return $tmp->configure(STRAT_MAXLOOPS, array_shift($_args)); case STRAT_CALLBACK: $cb = array_shift($_args); $this->exStrats[] = $tmp = new CallbackExitStrategy; return $tmp->configure(STRAT_CALLBACK, $cb, $_args); case STRAT_COND: $this->exStrats[] = $tmp = new ConditionalExitStrategy; return $tmp->configure(STRAT_COND, $this); default: trigger_error("Select mode - mode not found", E_USER_WARNING); return false; } } function clearExitStrategies () { $this->exStrats = array(); } function notifyPreSelect () { $r = true; foreach ($this->exStrats as $strat) { $r = $strat->preSelect($r); } return $r; } function notifySelectInit () { foreach ($this->exStrats as $strat) { $strat->init($this); } foreach ($this->chans as $chan) { $chan->startAllConsumers(); } } function notifyComplete () { foreach($this->exStrats as $strat) { $strat->complete(); } foreach ($this->chans as $chan) { $chan->onSelectEnd(); } } function doSelectRead () { $buff = $this->sock->readAll(); if ($buff && ($meths = $this->readMessages($buff))) { $this->unDelivered = array_merge($this->unDelivered, $meths); } else if ($buff == '') { $this->blocking = false; throw new \Exception("Empty read in blocking select loop : " . strlen($buff), 9864); } } function invoke (wire\Method $inMeth, $noWait=false) { if (! ($this->write($inMeth->toBin($this->getProtocolLoader())))) { throw new \Exception("Send message failed (1)", 5623); } if (! $noWait && $inMeth->getMethodProto()->getSpecResponseMethods()) { if ($inMeth->getMethodProto()->hasNoWaitField()) { foreach ($inMeth->getMethodProto()->getFields() as $f) { if ($f->getSpecDomainName() == 'no-wait' && $inMeth->getField($f->getSpecFieldName())) { return; } } } while (true) { if (! ($buff = $this->read())) { throw new \Exception(sprintf("(2) Send message failed for %s:\n", $inMeth->amqpClass), 5624); } $meths = $this->readMessages($buff); foreach (array_keys($meths) as $k) { $meth = $meths[$k]; unset($meths[$k]); if ($inMeth->isResponse($meth)) { if ($meths) { $this->unDelivered = array_merge($this->unDelivered, $meths); } return $meth; } else { $this->unDelivered[] = $meth; } } } } } private function readMessages ($buff) { if (is_null($this->readSrc)) { $src = new wire\Reader($buff); } else { $src = $this->readSrc; $src->append($buff); $this->readSrc = null; } $allMeths = array(); $pl = $this->getProtocolLoader(); while (true) { $meth = null; if ($this->incompleteMethods) { foreach ($this->incompleteMethods as $im) { if ($im->canReadFrom($src)) { $meth = $im; $rcr = $meth->readConstruct($src, $pl); break; } } } if (! $meth) { $meth = new wire\Method; $this->incompleteMethods[] = $meth; $rcr = $meth->readConstruct($src, $pl); } if ($meth->readConstructComplete()) { if (false !== ($p = array_search($meth, $this->incompleteMethods, true))) { unset($this->incompleteMethods[$p]); } if ($this->connected && $meth->getWireChannel() == 0) { $this->handleConnectionMessage($meth); } else if ($meth->getWireClassId() == 20 && ($chan = $this->chans[$meth->getWireChannel()])) { $chanR = $chan->handleChannelMessage($meth); if ($chanR === true) { $allMeths[] = $meth; } } else { $allMeths[] = $meth; } } if ($rcr === wire\Method::PARTIAL_FRAME) { $this->readSrc = $src; break; } else if ($src->isSpent()) { break; } } return $allMeths; } function getUndeliveredMessages () { return $this->unDelivered; } function deliverAll () { while ($this->unDelivered) { $meth = array_shift($this->unDelivered); if (isset($this->chans[$meth->getWireChannel()])) { $this->chans[$meth->getWireChannel()]->handleChannelDelivery($meth); } else { trigger_error("Message delivered on unknown channel", E_USER_WARNING); $this->unDeliverable[] = $meth; } } } function getUndeliverableMessages ($chan) { $r = array(); foreach (array_keys($this->unDeliverable) as $k) { if ($this->unDeliverable[$k]->getWireChannel() == $chan) { $r[] = $this->unDeliverable[$k]; } } return $r; } function removeUndeliverableMessages ($chan) { foreach (array_keys($this->unDeliverable) as $k) { if ($this->unDeliverable[$k]->getWireChannel() == $chan) { unset($this->unDeliverable[$k]); } } } function constructMethod ($class, $_args) { $method = (isset($_args[0])) ? $_args[0] : null; $args = (isset($_args[1])) ? $_args[1] : array(); $content = (isset($_args[2])) ? $_args[2] : null; $pl = $this->getProtocolLoader(); if (! ($cls = $pl('ClassFactory', 'GetClassByName', array($class)))) { throw new \Exception("Invalid Amqp class or php method", 8691); } else if (! ($meth = $cls->getMethodByName($method))) { throw new \Exception("Invalid Amqp method", 5435); } $m = new wire\Method($meth); foreach ($args as $k => $v) { $m->setField($k, $v); } $m->setContent($content); return $m; } } 