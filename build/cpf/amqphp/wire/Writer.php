<?php
 namespace amqphp\wire; use amqphp\protocol as proto; use amqphp\protocol\abstrakt; class Writer extends Protocol { private $binPackOffset = 0; function write ($value, $type, $tableField=false) { $implType = ($tableField) ? $this->getImplForTableType($type) : $this->getImplForXmlType($type); if (! $implType) { trigger_error(sprintf("Warning: Unknown Amqp type: %s", $type), E_USER_WARNING); $implType = ($tableField) ? $this->getTableTypeForValue($value) : $this->getXmlTypeForValue($value); if (! $implType) { trigger_error("Warning: no type mapping found for input type or value - nothing written", E_USER_WARNING); return; } } $r = $this->{"write$implType"}($value); if ($implType === 'Boolean') { $this->binPackOffset++; } else { $this->binPackOffset = 0; } } private function writeTable ($val) { if (is_array($val)) { $val = new Table($val); } else if (! ($val instanceof Table)) { $val = array(); } $p = strlen($this->bin); foreach ($val as $fName => $field) { $this->writeShortString($fName); $this->writeShortShortUInt(ord($field->getType())); $this->write($field->getValue(), $field->getType(), true); } $p2 = strlen($this->bin); $binSav = $this->bin; $this->bin = ''; $this->writeLongUInt($p2 - $p); $binLen = $this->bin; $this->bin = substr($binSav, 0, $p) . $binLen . substr($binSav, $p); } private function writeFieldArray (array $arr) { $p = strlen($this->bin); foreach ($arr as $item) { if (! ($item instanceof TableField)) { $item = new TableField($item); } $this->writeShortShortUInt(ord($item->getType())); $this->write($item->getValue(), $item->getType(), true); } $p2 = strlen($this->bin); $binSav = $this->bin; $this->bin = ''; $this->writeLongUInt($p2 - $p); $binLen = $this->bin; $this->bin = substr($binSav, 0, $p) . $binLen . substr($binSav, $p); } private function writeBoolean ($val) { if ($this->binPackOffset == 0) { if ($val) { $this->bin .= pack('C', 1); } else { $this->bin .= pack('C', 0); } } else { $tmp = unpack('C', substr($this->bin, -1)); $b = reset($tmp); if ($val) { $b += pow(2, $this->binPackOffset); } if ($this->binPackOffset > 6) { $this->binPackOffset = -1; } $this->bin = substr($this->bin, 0, -1) . pack('C', $b); } } private function writeShortShortInt ($val) { $this->bin .= pack('c', (int) $val); } private function writeShortShortUInt ($val) { $this->bin .= pack('C', (int) $val); } private function writeShortInt ($val) { $this->bin .= pack('s', (int) $val); } private function writeShortUInt ($val) { $this->bin .= pack('n', (int) $val); } private function writeLongInt ($val) { $this->bin .= pack('L', (int) $val); } private function writeLongUInt ($val) { $this->bin .= pack('N', (int) $val); } private function writeLongLongInt ($val) { error("Unimplemented *write* method %s", __METHOD__); } private function writeLongLongUInt ($val) { $tmp = array(); for ($i = 0; $i < 8; $i++) { $tmp[] = $val & 255; $val = ($val >> 8); } foreach (array_reverse($tmp) as $octet) { $this->bin .= chr($octet); } } private function writeFloat ($val) { $this->bin .= pack('f', (float) $val); } private function writeDouble ($val) { $this->bin .= pack('d', (float) $val); } private function writeDecimalValue ($val) { if (! ($val instanceof Decimal)) { $val = new Decimal($val); } $this->writeShortShortUInt($val->getScale()); $this->writeLongUInt($val->getUnscaled()); } private function writeShortString ($val) { $this->writeShortShortUInt(strlen($val)); $this->bin .= $val; } private function writeLongString ($val) { $this->writeLongUInt(strlen($val)); $this->bin .= $val; } }