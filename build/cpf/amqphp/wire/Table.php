<?php
 namespace amqphp\wire; use amqphp\protocol as proto; use amqphp\protocol\abstrakt; class Table implements \ArrayAccess, \Iterator { const ITER_MODE_SIMPLE = 1; const ITER_MODE_TYPED = 2; private $data = array(); private $iterMode = self::ITER_MODE_SIMPLE; private $iterP = 0; private $iterK; static function IsValidKey($k) { return is_string($k) && $k && (strlen($k) < 129) && preg_match("/[a-zA-Z\$\#][a-zA-Z-_\$\#]*/", $k); } function __construct(array $data = array()) { foreach ($data as $name => $av) { $this->offsetSet($name, $av); } } function offsetExists($k) { return array_key_exists($k, $this->data); } function offsetGet($k) { if (! $this->offsetExists($k)) { trigger_error(sprintf("Offset not found [0]: %s", $k), E_USER_WARNING); return null; } return $this->data[$k]; } function offsetSet($k, $v) { if ( ! self::IsValidKey($k)) { throw new \Exception("Invalid table key", 7255); } else if (! ($v instanceof TableField)) { $v = new TableField($v); } $this->data[$k] = $v; } function offsetUnset($k) { if (! isset($this->data[$k])) { trigger_error(sprintf("Offset not found [1]: %s", $k), E_USER_WARNING); } else { unset($this->data[$n]); } } function getArrayCopy() { $ac = array(); foreach ($this->data as $k => $v) { $ac[$k] = $v->getValue(); } return $ac; } function rewind() { $this->iterP = 0; $this->iterK = array_keys($this->data); } function current() { return $this->data[$this->iterK[$this->iterP]]; } function key() { return $this->iterK[$this->iterP]; } function next() { $this->iterP++; } function valid() { return isset($this->iterK[$this->iterP]); } } 